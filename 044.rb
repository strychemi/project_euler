# Pentagon numbers

=begin

Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?

=end

=begin

  Generating the pentagonal sequence and testing every pair combination doesn't work (takes years to completely run because of O(n^2) complexity). Basically, checking if the sequence contains the pentagonal numbers adds another complexity order to the algorithm because the double each loops contain two includes? methods as a check. This is why it takes forever to run.

  Instead, the inverse function can be used to give the ability to test whether an integer is a pentagonal number, so pentagonal numbers are computed on the fly and then their sum/differences are checked for pentagonality.

  For me, this was more of an optimization problem.

=end

=begin
def generate_pentagonals(nth)
  sequence = []
  (1..nth).each do |n|
    sequence.push( n * (3 * n - 1) / 2 )
  end
  return sequence
end

def pentagonal_pair(p)
  pairs = {}
  p.each do |j|
    p.each do |k|
      s = j + k
      d = (j - k).abs
      pairs[[j,k].sort] = d if p.include?(s) && p.include?(d)
    end
  end

  puts pairs
end

pentagonal_pair(generate_pentagonals(100))
=end


def pentagonal?(num)
  return (1 + (24 * num + 1) ** (0.5)) / 6.0 % 1.0 == 0.0
end

def pair
  limit = 3000
  smallest_diff = 0
  (1..limit).each do |j|
    (j+1..limit).each do |k|
      pj = j * (3 * j - 1) / 2
      pk = k * (3 * k - 1) / 2
      d = pk - pj
      s = pk + pj
      if pentagonal?(d) && pentagonal?(s)
        #puts "#{pj} #{pk}"
        smallest_diff = d
      end
    end
  end

  puts smallest_diff
end

pair
